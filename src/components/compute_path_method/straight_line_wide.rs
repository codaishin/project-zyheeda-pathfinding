use crate::traits::{
	computable_grid::{ComputeGrid, ComputeGridNode},
	compute_path::{ComputePath, NewComputer},
};
use std::{collections::HashSet, ops::RangeInclusive};

pub struct StraightLineWide;

impl NewComputer for StraightLineWide {
	fn new(_: ComputeGrid, _: HashSet<ComputeGridNode>) -> Self {
		StraightLineWide
	}
}

impl ComputePath for StraightLineWide {
	fn draw_connections(&self) -> bool {
		const { false }
	}

	fn path(&self, start: ComputeGridNode, end: ComputeGridNode) -> Vec<ComputeGridNode> {
		LineWide::new(start, end).collect()
	}
}

/// Uses my epic Bresenham's line algorithm hack.
///
/// This adds all nodes to the graph, that would
/// be "touched" by a square (1x1) traveling down the line
/// generated by Bresenham's line algorithm.
pub struct LineWide {
	orientation: Orientation,
	new_node: NewNodeFn,
	range: RangeInclusive<i32>,
}

impl LineWide {
	pub fn new(start: ComputeGridNode, end: ComputeGridNode) -> Self {
		let (low, high, new_node) = Self::normalize_layout(start, end);
		let (i_low, d_low) = match low.1 > low.0 {
			true => (1, low.1 - low.0),
			false => (-1, low.0 - low.1),
		};

		let orientation = match d_low {
			0 => Orientation::Straight { v_low: low.0 },
			_ => {
				let d_high = high.1 - high.0;
				let d_low_sub = d_low - 1;
				let d_high_sub = d_high - 1;
				let main = Step {
					d: (2 * d_low) - d_high,
					v_low: low.0,
					d_up: 2 * d_low,
					d_down: 2 * (d_low - d_high),
				};
				let top = Step {
					d: (2 * d_low_sub) - d_high_sub,
					v_low: low.0 + i_low,
					d_up: 2 * d_low_sub,
					d_down: 2 * (d_low_sub - d_high_sub),
				};
				let btm = Step {
					d: top.d,
					v_low: low.0,
					d_up: top.d_up,
					d_down: top.d_down,
				};

				Orientation::Odd(Line {
					i_low,
					start: high.0,
					end: high.1,
					main,
					top,
					btm,
					additional_nodes: [None, None],
				})
			}
		};

		Self {
			range: high.0..=high.1,
			new_node,
			orientation,
		}
	}

	fn normalize_layout(start: ComputeGridNode, end: ComputeGridNode) -> (Low, High, NewNodeFn) {
		let dx = (end.x - start.x).abs();
		let dy = (end.y - start.y).abs();
		let is_low = dx > dy;

		match is_low {
			true if start.x < end.x => (Low(start.y, end.y), High(start.x, end.x), Low::node),
			true => (Low(end.y, start.y), High(end.x, start.x), Low::node),
			false if start.y < end.y => (Low(start.x, end.x), High(start.y, end.y), High::node),
			false => (Low(end.x, start.x), High(end.y, start.y), High::node),
		}
	}
}

impl Iterator for LineWide {
	type Item = ComputeGridNode;

	fn next(&mut self) -> Option<Self::Item> {
		match &mut self.orientation {
			Orientation::Straight { v_low } => {
				let v_high = self.range.next()?;
				let node = (self.new_node)(*v_low, v_high);
				Some(node)
			}
			Orientation::Odd(line) => {
				match &mut line.additional_nodes {
					[node, _] if node.is_some() => return node.take(),
					[_, node] if node.is_some() => return node.take(),
					_ => {}
				}

				let v_high = self.range.next()?;
				let node = (self.new_node)(line.main.v_low, v_high);
				line.main.step(line.i_low);

				if v_high != line.end {
					let node_top = (self.new_node)(line.top.v_low, v_high);
					line.top.step_early(line.i_low);
					if node_top != node {
						line.additional_nodes[1] = Some(node_top);
					}
				}

				if v_high != line.start {
					let node_btm = (self.new_node)(line.btm.v_low, v_high);
					line.btm.step(line.i_low);
					if node_btm != node {
						line.additional_nodes[0] = Some(node_btm);
					}
				}

				Some(node)
			}
		}
	}
}

enum Orientation {
	Straight { v_low: i32 },
	Odd(Line),
}

struct Line {
	i_low: i32,
	start: i32,
	end: i32,
	main: Step,
	top: Step,
	btm: Step,
	additional_nodes: [Option<ComputeGridNode>; 2],
}

type NewNodeFn = fn(i32, i32) -> ComputeGridNode;

struct Low(i32, i32);

impl Low {
	fn node(x: i32, y: i32) -> ComputeGridNode {
		ComputeGridNode::new(y, x)
	}
}

struct High(i32, i32);

impl High {
	fn node(x: i32, y: i32) -> ComputeGridNode {
		ComputeGridNode::new(x, y)
	}
}

#[derive(Debug, PartialEq)]
struct Step {
	d: i32,
	v_low: i32,
	d_up: i32,
	d_down: i32,
}

impl Step {
	fn step(&mut self, i_low: i32) {
		if self.d <= 0 {
			self.d += self.d_up;
			return;
		}

		self.v_low += i_low;
		self.d += self.d_down;
	}

	fn step_early(&mut self, i_low: i32) {
		if self.d < 0 {
			self.d += self.d_up;
			return;
		}

		self.v_low += i_low;
		self.d += self.d_down;
	}
}
