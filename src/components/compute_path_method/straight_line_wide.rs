use crate::traits::{
	computable_grid::{ComputeGrid, ComputeGridNode},
	compute_path::{ComputePath, NewComputer},
};
use std::{collections::HashSet, ops::RangeInclusive};

pub struct StraightLineWide;

impl NewComputer for StraightLineWide {
	fn new(_: ComputeGrid, _: HashSet<ComputeGridNode>) -> Self {
		StraightLineWide
	}
}

impl ComputePath for StraightLineWide {
	fn draw_connections(&self) -> bool {
		const { false }
	}

	fn path(&self, start: ComputeGridNode, end: ComputeGridNode) -> Vec<ComputeGridNode> {
		LineWide::new(start, end).collect()
	}
}

/// Uses my epic Bresenham's line algorithm hack.
///
/// This adds all nodes to the graph, that would
/// be "touched" by a square (1x1) traveling down the line
/// generated by Bresenham's line algorithm.
pub struct LineWide {
	orientation: Orientation,
	new_node: NewNodeFn,
	range: RangeInclusive<i32>,
}

impl LineWide {
	pub fn new(start: ComputeGridNode, end: ComputeGridNode) -> Self {
		let (low, high, new_node) = Self::normalize_layout(start, end);
		let (i_low, d_low) = match low.1 > low.0 {
			true => (1, low.1 - low.0),
			false => (-1, low.0 - low.1),
		};

		let orientation = match d_low {
			0 => Orientation::Straight { v_low: low.0 },
			_ => {
				let d_high = high.1 - high.0;
				let step = Step {
					d: (2 * d_low) - d_high,
					v_lows: [low.0; 2],
					d_up: 2 * d_low,
					d_down: 2 * (d_low - d_high),
				};

				Orientation::Odd(Line {
					i_low,
					d_low_start: low.0,
					d_low_end: low.1,
					step,
					additional_nodes: [None; 3],
				})
			}
		};

		Self {
			range: high.0..=high.1,
			new_node,
			orientation,
		}
	}

	fn normalize_layout(start: ComputeGridNode, end: ComputeGridNode) -> (Low, High, NewNodeFn) {
		let dx = (end.x - start.x).abs();
		let dy = (end.y - start.y).abs();
		let is_low = dx > dy;

		match is_low {
			true if start.x < end.x => (Low(start.y, end.y), High(start.x, end.x), Low::node),
			true => (Low(end.y, start.y), High(end.x, start.x), Low::node),
			false if start.y < end.y => (Low(start.x, end.x), High(start.y, end.y), High::node),
			false => (Low(end.x, start.x), High(end.y, start.y), High::node),
		}
	}
}

impl Iterator for LineWide {
	type Item = ComputeGridNode;

	fn next(&mut self) -> Option<Self::Item> {
		match &mut self.orientation {
			Orientation::Straight { v_low } => {
				let v_high = self.range.next()?;
				let node = (self.new_node)(*v_low, v_high);
				Some(node)
			}
			Orientation::Odd(line) => match &mut line.additional_nodes {
				[node, _, _] if node.is_some() => node.take(),
				[_, node, _] if node.is_some() => node.take(),
				[_, _, node] if node.is_some() => node.take(),
				_ => {
					let high = self.range.next()?;
					let low_0 = line.step.v_lows[0];
					let low_1 = line.step.v_lows[1];

					let node = (self.new_node)(low_0, high);

					if low_0 != line.d_low_start {
						line.additional_nodes[0] = Some((self.new_node)(low_0 - line.i_low, high));
					}

					if low_0 != low_1 {
						line.additional_nodes[1] = Some((self.new_node)(low_1, high));
					}

					if low_1 != line.d_low_end {
						line.additional_nodes[2] = Some((self.new_node)(low_1 + line.i_low, high));
					}

					line.step.step(line.i_low);

					Some(node)
				}
			},
		}
	}
}

enum Orientation {
	Straight { v_low: i32 },
	Odd(Line),
}

struct Line {
	i_low: i32,
	d_low_start: i32,
	d_low_end: i32,
	step: Step,
	additional_nodes: [Option<ComputeGridNode>; 3],
}

type NewNodeFn = fn(i32, i32) -> ComputeGridNode;

struct Low(i32, i32);

impl Low {
	fn node(x: i32, y: i32) -> ComputeGridNode {
		ComputeGridNode::new(y, x)
	}
}

struct High(i32, i32);

impl High {
	fn node(x: i32, y: i32) -> ComputeGridNode {
		ComputeGridNode::new(x, y)
	}
}

#[derive(Debug, PartialEq)]
struct Step {
	d: i32,
	v_lows: [i32; 2],
	d_up: i32,
	d_down: i32,
}

impl Step {
	fn step(&mut self, i_low: i32) {
		if self.d < 0 {
			self.d += self.d_up;
			return;
		}

		if self.d == 0 {
			self.d += self.d_up;
			self.v_lows[1] += i_low;
			return;
		}

		self.v_lows[0] += i_low;
		self.v_lows[1] = self.v_lows[0];
		self.d += self.d_down;
	}
}
